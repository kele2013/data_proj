# Requirement:
#   pip install "openai<1.0"
# Usage:
#   python openai_api.py
# Visit http://localhost:8000/docs for documents.

import base64
import copy
import json
import time
from argparse import ArgumentParser
from contextlib import asynccontextmanager
from pprint import pprint
from typing import Dict, List, Literal, Optional, Union

import uvicorn
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from sse_starlette.sse import EventSourceResponse
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response



from http import HTTPStatus
import dashscope
from dashscope import Generation
import openai

#dashscope.api_key="sk-6461762ab9b6464b8a28456992110153"
#dashscope.api_key="sk-f68a9da802bb4926982d233b076769ba"
dashscope.api_key="sk-9f3cf1ca1de0435495383bd65df2e9ee"


class BasicAuthMiddleware(BaseHTTPMiddleware):

    def __init__(self, app, username: str, password: str):
        super().__init__(app)
        self.required_credentials = base64.b64encode(
            f'{username}:{password}'.encode()).decode()

    async def dispatch(self, request: Request, call_next):
        authorization: str = request.headers.get('Authorization')
        if authorization:
            try:
                schema, credentials = authorization.split()
                if credentials == self.required_credentials:
                    return await call_next(request)
            except ValueError:
                pass

        headers = {'WWW-Authenticate': 'Basic'}
        return Response(status_code=401, headers=headers)


@asynccontextmanager
async def lifespan(app: FastAPI):  # collects GPU memory
    yield
   # _gc(forced=True)


app = FastAPI(lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=['*'],
    allow_credentials=True,
    allow_methods=['*'],
    allow_headers=['*'],
)

# //input_tokens": 25, "output_tokens": 246, "total_tokens": 271
class Usage(BaseModel):
    input_tokens:int
    output_tokens:int
    prompt_tokens:int
    completion_tokens:int
    total_tokens:int


usage = Usage(input_tokens=25,output_tokens=246,total_tokens=7202,prompt_tokens=7202,completion_tokens=271)


class ModelCard(BaseModel):
    id: str
    object: str = 'model'
    created: int = Field(default_factory=lambda: int(time.time()))
    owned_by: str = 'owner'
    root: Optional[str] = None
    parent: Optional[str] = None
    permission: Optional[list] = None


class ModelList(BaseModel):
    object: str = 'list'
    data: List[ModelCard] = []


class Function_(BaseModel):
    arguments: str
    """
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """

    name: str
    """The name of the function to call."""


class ChatCompletionMessageToolCall(BaseModel):
    id: str
    """The ID of the tool call."""

    function: Function_
    """The function that the model called."""

    type: Literal["function"]
    """The type of the tool. Currently, only `function` is supported."""


class ChatMessage(BaseModel):
    role: Literal['user', 'assistant', 'system', 'function','tool']
    content: Optional[str]
    function_call: Optional[Dict] = None
    tool_calls:Optional[List[ChatCompletionMessageToolCall]] = None


class DeltaMessage(BaseModel):
    role: Optional[Literal['user', 'assistant', 'system']] = None
    content: Optional[str] = None


class Param(BaseModel):
    type: str
    properties: Optional[object] = None

class Function(BaseModel):
    name:str
    description:str
    parameters: Param
    required:Optional[List[str]] = None

class FunctionTool(BaseModel):
    type: str
    function: Function

class ChatCompletionRequest(BaseModel):
    model: str
    messages: List[ChatMessage]
    functions: Optional[List[Dict]] = None
    temperature: Optional[float] = None
    top_p: Optional[float] = None
    top_k: Optional[int] = None
    max_length: Optional[int] = None
    stream: Optional[bool] = False
    stop: Optional[List[str]] = None
    tools: Optional[List[FunctionTool]] = None
    additional_kwargs:Optional[Dict]=None


class ChatCompletionResponseChoice(BaseModel):
    index: int
    message: Union[ChatMessage]
    finish_reason: Literal['stop', 'length', 'tool_calls']


class ChatCompletionResponseStreamChoice(BaseModel):
    index: int
    delta: DeltaMessage
    finish_reason: Optional[Literal['stop', 'length']]


class ChatCompletionResponse(BaseModel):
    id: str
    usage: Usage
    model: str
    object: Literal['chat.completion', 'chat.completion.chunk']
    choices: List[Union[ChatCompletionResponseChoice,
                        ChatCompletionResponseStreamChoice]]
    created: Optional[int] = Field(default_factory=lambda: int(time.time()))

class EmbeddingData(BaseModel):
    object: Literal['embedding']
    embedding: List[float]
    index:int

class EmbeddingResponse(BaseModel):
    object: str
    data: List[EmbeddingData]
    model:str
    usage:Usage

class EmbeddingRequest(BaseModel):
    model:str
    input:str


@app.get('/v1/models', response_model=ModelList)
async def list_models():
    global model_args
    model_card = ModelCard(id='text-embedding-ada-002')
    return ModelList(data=[model_card])


# To work around that unpleasant leading-\n tokenization issue!
def add_extra_stop_words(stop_words):
    if stop_words:
        _stop_words = []
        _stop_words.extend(stop_words)
        for x in stop_words:
            s = x.lstrip('\n')
            if s and (s not in _stop_words):
                _stop_words.append(s)
        return _stop_words
    return stop_words


def trim_stop_words(response, stop_words):
    if stop_words:
        for stop in stop_words:
            idx = response.find(stop)
            if idx != -1:
                response = response[:idx]
    return response


TOOL_DESC = (
    '{name_for_model}: Call this tool to interact with the {name_for_human} API.'
    ' What is the {name_for_human} API useful for? {description_for_model} Parameters: {parameters}'
)

REACT_INSTRUCTION = """Answer the following questions as best you can. You have access to the following APIs:

{tools_text}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tools_name_text}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can be repeated zero or more times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin!"""

_TEXT_COMPLETION_CMD = object()


def parse_messages(messages, functions):
    if all(m.role != 'user' for m in messages):
        raise HTTPException(
            status_code=400,
            detail='Invalid request: Expecting at least one user message.',
        )

    messages = copy.deepcopy(messages)
    if messages[0].role == 'system':
        system = messages.pop(0).content.lstrip('\n').rstrip()
    else:
        system = 'You are a helpful assistant.'

    if functions:
        tools_text = []
        tools_name_text = []
        for func_info in functions:
            name = func_info.get('name', '')
            name_m = func_info.get('name_for_model', name)
            name_h = func_info.get('name_for_human', name)
            desc = func_info.get('description', '')
            desc_m = func_info.get('description_for_model', desc)
            tool = TOOL_DESC.format(
                name_for_model=name_m,
                name_for_human=name_h,
                # Hint: You can add the following format requirements in description:
                #   "Format the arguments as a JSON object."
                #   "Enclose the code within triple backticks (`) at the beginning and end of the code."
                description_for_model=desc_m,
                parameters=json.dumps(func_info['parameters'],
                                      ensure_ascii=False),
            )
            tools_text.append(tool)
            tools_name_text.append(name_m)
        tools_text = '\n\n'.join(tools_text)
        tools_name_text = ', '.join(tools_name_text)
        instruction = (REACT_INSTRUCTION.format(
            tools_text=tools_text,
            tools_name_text=tools_name_text,
        ).lstrip('\n').rstrip())
    else:
        instruction = ''

    messages_with_fncall = messages
    messages = []
    for m_idx, m in enumerate(messages_with_fncall):
        role, content, func_call = m.role, m.content, m.function_call
        content = content or ''
        content = content.lstrip('\n').rstrip()
        if role == 'function':
            if (len(messages) == 0) or (messages[-1].role != 'assistant'):
                raise HTTPException(
                    status_code=400,
                    detail=
                    'Invalid request: Expecting role assistant before role function.',
                )
            messages[-1].content += f'\nObservation: {content}'
            if m_idx == len(messages_with_fncall) - 1:
                # add a prefix for text completion
                messages[-1].content += '\nThought:'
        elif role == 'assistant':
            if len(messages) == 0:
                raise HTTPException(
                    status_code=400,
                    detail=
                    'Invalid request: Expecting role user before role assistant.',
                )
            if func_call is None:
                if functions:
                    content = f'Thought: I now know the final answer.\nFinal Answer: {content}'
            else:
                f_name, f_args = func_call['name'], func_call['arguments']
                if not content.startswith('Thought:'):
                    content = f'Thought: {content}'
                content = f'{content}\nAction: {f_name}\nAction Input: {f_args}'
            if messages[-1].role == 'user':
                messages.append(
                    ChatMessage(role='assistant',
                                content=content.lstrip('\n').rstrip()))
            else:
                messages[-1].content += '\n' + content
        elif role == 'user' or role == 'tool':
            messages.append(
                ChatMessage(role='user',
                            content=content.lstrip('\n').rstrip()))
        else:
            raise HTTPException(
                status_code=400,
                detail=f'Invalid request: Incorrect role {role}.')

    query = _TEXT_COMPLETION_CMD
    if messages[-1].role == 'user':
        query = messages[-1].content
        messages = messages[:-1]

    if len(messages) % 2 != 0:
        raise HTTPException(status_code=400, detail='Invalid request')

    history = []  # [(Q1, A1), (Q2, A2), ..., (Q_last_turn, A_last_turn)]
    for i in range(0, len(messages), 2):
        if messages[i].role == 'user' and messages[i + 1].role == 'assistant':
            usr_msg = messages[i].content.lstrip('\n').rstrip()
            bot_msg = messages[i + 1].content.lstrip('\n').rstrip()
            if instruction and (i == len(messages) - 2):
                usr_msg = f'{instruction}\n\nQuestion: {usr_msg}'
                instruction = ''
            history.append([usr_msg, bot_msg])
        else:
            raise HTTPException(
                status_code=400,
                detail=
                'Invalid request: Expecting exactly one user (or function) role before every assistant role.',
            )
    if instruction:
        assert query is not _TEXT_COMPLETION_CMD
        query = f'{instruction}\n\nQuestion: {query}'
    return query, history, system



import random    
def parse_response(response):
    content = response.output.choices[0]['message']['content'] or 'tools call'
    choice_data = ChatCompletionResponseChoice(
            index=0,
            message=ChatMessage(role='assistant', content=content),
            finish_reason='stop',
        )
    try:
        mess = response.output.choices[0].message
        tc = mess['tool_calls']
        func = tc[0]['function']
        func_name = func['name']
        func_args = func['arguments']
        f = {
                'name': func_name,
                'arguments': func_args,
            }
        fc = ChatCompletionMessageToolCall(
                    id=str(random.randint(1, 100000000)),
                    function=f,
                    type='function'
                )
    
        list = []
        list.append(fc)
        choice_data = ChatCompletionResponseChoice(
            index=0,
            message=ChatMessage(
                role='assistant',
                content='',
                tool_calls=list,
            ),
            finish_reason='tool_calls',
        )
    except:
        print('parse_response:fail.')
        pass
    return choice_data



def chat_prompt(prompt):
    response = dashscope.Generation.call(
        model=dashscope.Generation.Models.qwen_turbo,
        prompt=prompt
    )
    # The response status_code is HTTPStatus.OK indicate success,
    # otherwise indicate request is failed, you can get error code
    # and message from code and message.
    text = ""
    if response.status_code == HTTPStatus.OK:





        # print(response.output)  # The output text
        # print(response.usage)  # The usage information
        text = response.output
        pass
    else:
        pass
        print(response.code)  # The error code.
        print(response.message)  # The error message.
    return text

# completion mode, not chat mode
def text_complete_last_message(history, stop_words_ids, gen_kwargs, system):
    im_start = '<|im_start|>'
    im_end = '<|im_end|>'
    prompt = f'{im_start}system\n{system}{im_end}'
    for i, (query, response) in enumerate(history):
        query = query.lstrip('\n').rstrip()
        response = response.lstrip('\n').rstrip()
        prompt += f'\n{im_start}user\n{query}{im_end}'
        prompt += f'\n{im_start}assistant\n{response}{im_end}'
    prompt = prompt[:-len(im_end)]

    # _stop_words_ids = [tokenizer.encode(im_end)]
    # if stop_words_ids:
    #     for s in stop_words_ids:
    #         _stop_words_ids.append(s)
    # stop_words_ids = _stop_words_ids

    # input_ids = torch.tensor([tokenizer.encode(prompt)]).to(model.device)
    # output = model.generate(input_ids,
    #                         stop_words_ids=stop_words_ids,
    #                         **gen_kwargs).tolist()[0]
    # output = tokenizer.decode(output, errors='ignore')
    # assert output.startswith(prompt)
    # output = output[len(prompt):]
    # output = trim_stop_words(output, ['<|endoftext|>', im_end])
    # print(f'<completion>\n{prompt}\n<!-- *** -->\n{output}\n</completion>')
    return chat_prompt(prompt)

def formatTools(request: ChatCompletionRequest):
    tools = []

    if request.tools is not None:
        for x in range (len(request.tools)):
            f :FunctionTool = request.tools[x]
            # print(f'func:{f}')
            s = {
                "type": "function",
                "function": {
                    "name": f.function.name,
                    "description": f.function.description,
                    "parameters": {
                        "type": "object",
                        "properties": f.function.parameters.properties,
                    }
                }
            }
            # print(f's:{s}')
            tools.append(s)
        return tools
    return None
    pass

def chat_messages(query, system, history, tools):
    from dashscope.api_entities.dashscope_response import Role
    import random 
    messages=[]
    messages.append({'role': Role.SYSTEM, 'content': system})
    if len(history) > 0:
        for i, (q, response) in enumerate(history):
            q = q.lstrip('\n').rstrip() or 'tool calls'
            messages.append({'role': Role.USER, 'content': q})
            response = response.lstrip('\n').rstrip() or 'tool calls'
            messages.append({'role': Role.ASSISTANT, 'content': response})
    messages.append({'role': Role.USER, 'content': query})
    # print(messages)
    response = dashscope.Generation.call(
        dashscope.Generation.Models.qwen_plus,
        messages=messages,
        top_k=10,
        seed=random.randint(1, 10000),
        result_format='message',
        tools = tools,
    )

    full_content = ''
    if response.status_code == HTTPStatus.OK:
        mess = response.output.choices[0]['message']
        print(f'chat_messages-mess:{mess}')
        if 'tool_calls' in mess:
            return response
        else:
            full_content += mess['content']

    else:
        print('Request id: %s, Status code: %s, error code: %s, error message: %s' % (
            response.request_id, response.status_code,
            response.code, response.message
        ))
    return full_content

@app.post('/v1/chat/completions', response_model=ChatCompletionResponse)
async def create_chat_completion(request_: ChatCompletionRequest):
    # data = await request_.json()
    # print(f"{data}")
    request:ChatCompletionRequest = request_ 
    gen_kwargs = {}
    if request.top_k is not None:
        gen_kwargs['top_k'] = request.top_k
    if request.temperature is not None:
        if request.temperature < 0.01:
            gen_kwargs['top_k'] = 1  # greedy decoding
        else:
            # Not recommended. Please tune top_p instead.
            gen_kwargs['temperature'] = request.temperature
    if request.top_p is not None:
        gen_kwargs['top_p'] = request.top_p

    stop_words = add_extra_stop_words(request.stop)
    if request.functions:
        print(f'{request.functions}')
        stop_words = stop_words or []
        if 'Observation:' not in stop_words:
            stop_words.append('Observation:')

    query, history, system = parse_messages(request.messages,
                                            request.functions)
    print(f'history:{history}')
    print(f'system:{system}')
    print(f'query:{query}')

    if request.stream:
        print("stream")
        raise HTTPException(
            status_code=400,
            detail=
            'Invalid request: Function calling is not yet implemented for stream mode.',
        )
    #     generate = predict(query,
    #                        history,
    #                        request.model,
    #                        stop_words,
    #                        gen_kwargs,
    #                        system=system)
    #     print(f"generate")
    #     return EventSourceResponse(generate, media_type='text/event-stream')

    if query is _TEXT_COMPLETION_CMD:
        print("_TEXT_COMPLETION_CMD")
        response = text_complete_last_message(history,
                                              stop_words_ids=None,
                                              gen_kwargs=gen_kwargs,
                                              system=system)
    else:
        if system is None:
            system='You are a helpful assistant.'
        tools = formatTools(request)
        response= chat_messages(query,system,history,tools)
        print(f'{query}\n<!-- *** -->\n{response}\n</chat>')
        
    if request.tools is not None and type(response) != str :
        # print(f"request.tools:{request.tools}")
        choice_data = parse_response(response)
        # print(f'choice_data:{choice_data}')
    else:
        print(f"response--")
        choice_data = ChatCompletionResponseChoice(
            index=0,
            message=ChatMessage(role='assistant', content=response),
            finish_reason='stop',
        )
    return ChatCompletionResponse(model=request.model,
                                  choices=[choice_data],
                                  object='chat.completion',
                                  id ='0',
                                  usage=usage,
                                  )


def _dump_json(data: BaseModel, *args, **kwargs) -> str:
    try:
        return data.model_dump_json(*args, **kwargs)
    except AttributeError:  # pydantic<2.0.0
        return data.json(*args, **kwargs)  # noqa

def chat_stream(query):
    messages = [
        {'role': 'user', 'content': query}]
    res = Generation.call(
        Generation.Models.qwen_turbo,
        messages=messages,
        result_format='message',  # set the result to be "message" format.
        stream=True,
        incremental_output=True  # get streaming output incrementally
    )
    text = ""
    for chunk in res:
        if chunk.status_code == HTTPStatus.OK:
            text += chunk.output.choices[0]['message']['content']
        else:
            text += ""
        yield text    

# async def predict(
#     query: str,
#     history: List[List[str]],
#     model_id: str,
#     stop_words: List[str],
#     gen_kwargs: Dict,
#     system: str,
# ):
#     choice_data = ChatCompletionResponseStreamChoice(
#         index=0, delta=DeltaMessage(role='assistant'), finish_reason=None)
#     chunk = ChatCompletionResponse(model=model_id,
#                                    choices=[choice_data],
#                                    object='chat.completion.chunk',
#                                    id='0',
#                                    usage=usage)
#     yield '{}'.format(_dump_json(chunk, exclude_unset=True))

#     current_length = 0
#     stop_words_ids = None

#     delay_token_num = max([len(x) for x in stop_words]) if stop_words_ids else 0
#     response_generator = chat_stream(query)
#     for _new_response in response_generator:
#         if len(_new_response) <= delay_token_num:
#             continue
#         new_response = _new_response[:-delay_token_num] if delay_token_num else _new_response

#         if len(new_response) == current_length:
#             continue

#         new_text = new_response[current_length:]
#         current_length = len(new_response)

#         choice_data = ChatCompletionResponseStreamChoice(
#             index=0, delta=DeltaMessage(content=new_text), finish_reason=None)
#         chunk = ChatCompletionResponse(model=model_id,
#                                        choices=[choice_data],
#                                        object='chat.completion.chunk',
#                                     id='0',
#                                    usage=usage)
#         yield '{}'.format(_dump_json(chunk, exclude_unset=True))
    
#     if current_length != len(_new_response):
#         # Determine whether to print the delay tokens
#         delayed_text = _new_response[current_length:]
#         new_text = trim_stop_words(delayed_text, stop_words)
#         if len(new_text) > 0:
#             choice_data = ChatCompletionResponseStreamChoice(
#                 index=0, delta=DeltaMessage(content=new_text), finish_reason=None)
#             chunk = ChatCompletionResponse(model=model_id,
#                                         choices=[choice_data],
#                                         object='chat.completion.chunk',                                   
#                                         id='0',
#                                         usage=usage)
#             yield '{}'.format(_dump_json(chunk, exclude_unset=True))

#     choice_data = ChatCompletionResponseStreamChoice(index=0,
#                                                      delta=DeltaMessage(),
#                                                      finish_reason='stop')
#     chunk = ChatCompletionResponse(model=model_id,
#                                    choices=[choice_data],
#                                    object='chat.completion.chunk',
#                                    id='0',
#                                    usage=usage)
#     yield '{}'.format(_dump_json(chunk, exclude_unset=True))
#     yield '[DONE]'

def embed_with_str2(query):
    resp = dashscope.TextEmbedding.call(
        model=dashscope.TextEmbedding.Models.text_embedding_v1,
        input=query)
    if resp.status_code == HTTPStatus.OK:
        list1 = resp.output['embeddings'][0]['embedding']
        data = EmbeddingData(object='embedding',
                                    embedding=list1,
                                    index=0)
        list2 =[]
        list2.append(data)
        chunk =  EmbeddingResponse(object='list',data=list2,model='text-embedding-ada-002',usage=usage)
        return chunk
    return EmbeddingResponse(object='list',data=[],model='text-embedding-ada-002',usage=usage)


# 最多支持25条，每条最长支持2048tokens
DASHSCOPE_MAX_BATCH_SIZE = 1024

from typing import Generator, List
def batched(inputs: List,
            batch_size: int = DASHSCOPE_MAX_BATCH_SIZE) -> Generator[List, None, None]:
    for i in range(0, len(inputs), batch_size):
        yield inputs[i:i + batch_size]


def embed_with_list_of_str(inputs: List):
    print(f'embed_with_list_of_str-inputs:{inputs}')
    result = None  # merge the results.
    batch_counter = 0
    for batch in batched(inputs):
        print(f'index:{batch_counter},input:{batch}')
        resp = dashscope.TextEmbedding.call(
            model=dashscope.TextEmbedding.Models.text_embedding_v1,
            input=batch)
        print(f'embed_with_list_of_str--resp:{resp}')
        if resp.status_code == HTTPStatus.OK:
            if result is None:
                result = resp
            else:
                for emb in resp.output['embeddings']:
                    emb['index'] += batch_counter
                    result.output['embeddings'].append(emb)
        else:
            pass
            # print(resp)
        batch_counter += len(batch)
    return result


def embed_with_str(inputs: List):
    list2 =[]
    resp = embed_with_list_of_str(inputs)
    print(f'embed_with_str-resp:{resp}')
    if resp.output is not None and 'embeddings' in resp.output:
        for i in range(len(resp.output['embeddings'])):
            list1 = resp.output['embeddings'][i]['embedding']
            data = EmbeddingData(object='embedding',
                                    embedding=list1,
                                    index=i)
            list2.append(data)
        chunk =  EmbeddingResponse(object='list',data=list2,model='text-embedding-ada-002',usage=usage)
        return chunk
    return EmbeddingResponse(object='list',data=[],model='text-embedding-ada-002',usage=usage)

# v1/embeddings
@app.post('/v1/embeddings', response_model=EmbeddingResponse)
async def embeddings(request: Request):
    data = await request.json()
    if data is not None:
        input = data['input']
        generate = embed_with_str(input)
        return generate

    raise HTTPException(
        status_code=400,
        detail=
        'Invalid request: Function calling is not yet implemented for stream mode.',
    )

def _get_args():
    parser = ArgumentParser()
    parser.add_argument(
        '-c',
        '--checkpoint-path',
        type=str,
        default='Qwen/Qwen-7B-Chat',
        help='Checkpoint name or path, default to %(default)r',
    )
    parser.add_argument('--api-auth', help='API authentication credentials')
    parser.add_argument('--cpu-only',
                        action='store_true',
                        help='Run demo with CPU only')
    parser.add_argument('--server-port',
                        type=int,
                        default=8001,
                        help='Demo server port.')
    parser.add_argument(
        '--server-name',
        type=str,
        default='127.0.0.1',
        help=
        'Demo server name. Default: 127.0.0.1, which is only visible from the local computer.'
        ' If you want other computers to access your server, use 0.0.0.0 instead.',
    )
    parser.add_argument(
        '--disable-gc',
        action='store_true',
        help='Disable GC after each response generated.',
    )

    args = parser.parse_args()
    return args


if __name__ == '__main__':
    args = _get_args()
    if args.api_auth:
        app.add_middleware(BasicAuthMiddleware,
                           username=args.api_auth.split(':')[0],
                           password=args.api_auth.split(':')[1])

    if args.cpu_only:
        device_map = 'cpu'
    else:
        device_map = 'auto'

    uvicorn.run(app, host=args.server_name, port=args.server_port, workers=1)
